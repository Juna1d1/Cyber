<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Detector — Object + Color + Distance (TensorFlow.js)</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial; margin:0; background:linear-gradient(180deg,#071124 0%, #071a1f 100%); color:#e6eef6}
    .wrap{max-width:1100px;margin:24px auto;padding:18px}
    header{display:flex;gap:16px;align-items:center}
    h1{margin:0;font-size:20px}
    .grid{display:grid;grid-template-columns:420px 1fr;gap:18px;margin-top:16px}
    .card{background:rgba(255,255,255,0.03);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    video{border-radius:8px;display:block;width:100%;height:auto;background:#000}
    canvas{position:absolute;left:0;top:0}
    .video-wrap{position:relative}
    .controls{display:flex;flex-direction:column;gap:8px}
    label{font-size:13px;color:var(--muted)}
    input,select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    .row{display:flex;gap:8px}
    .small{font-size:12px;color:var(--muted)}
    footer{margin-top:14px;font-size:12px;color:var(--muted)}
    .stats{display:flex;gap:12px;flex-wrap:wrap}
    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px}
    .color-swatch{width:28px;height:28px;border-radius:6px;border:1px solid rgba(0,0,0,0.25);display:inline-block;vertical-align:middle}
    .hint{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Detector — Object + Color + Distance (TensorFlow.js)</h1>
      <div style="margin-left:auto" class="small">Single-file HTML • Ready for GitHub Pages</div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="video-wrap">
          <video id="video" playsinline autoplay muted></video>
          <canvas id="overlay"></canvas>
        </div>

        <div style="margin-top:12px" class="controls">
          <div class="row">
            <label>Camera</label>
            <select id="cameraList"></select>
            <button id="startBtn">Start</button>
            <button id="stopBtn">Stop</button>
          </div>

          <div class="row">
            <label>Model</label>
            <select id="modelSelect">
              <option value="coco">COCO-SSD (recommended)</option>
            </select>
            <label class="small">Process every</label>
            <select id="skipFrames"><option>1</option><option>2</option><option>3</option><option>4</option></select>
          </div>

          <div class="row">
            <label class="small">Show boxes</label>
            <input id="showBoxes" type="checkbox" checked />
            <label class="small">Show labels</label>
            <input id="showLabels" type="checkbox" checked />
          </div>

          <hr />

          <label>Distance calibration</label>
          <div class="row">
            <input id="knownWidth" placeholder="Known width (cm) e.g. 14" />
            <input id="knownDistance" placeholder="Distance used in calibration (cm) e.g. 50" />
            <select id="classForCalibration"><option value="person">person</option><option value="bottle">bottle</option><option value="cell phone">cell phone</option><option value="cup">cup</option></select>
            <button id="calibrateBtn">Calibrate</button>
          </div>
          <div class="small hint">Calibration: center a known object of width X cm at distance Y cm and click Calibrate. You only need to do this once per camera.</div>

          <hr />

          <div class="stats">
            <div class="badge">Model status: <span id="modelStatus">—</span></div>
            <div class="badge">FPS: <span id="fps">—</span></div>
            <div class="badge">Last detection: <span id="lastDetect">—</span></div>
            <div class="badge">Focal: <span id="focal">—</span></div>
            <div class="badge">Estimated dist: <span id="estDist">—</span></div>
          </div>

        </div>
      </div>

      <div class="card">
        <h3>How it works</h3>
        <p class="small">This single-file demo uses TensorFlow.js (<code>coco-ssd</code>) to detect objects in real-time from your camera. For each detected bounding box we sample the pixels to compute the dominant color and — if you've calibrated — estimate distance using a simple pinhole camera formula.</p>

        <h3>Export / Usage</h3>
        <ol class="small">
          <li>Save this file as <code>index.html</code> in a GitHub repo's root.</li>
          <li>Enable GitHub Pages on the repository (Settings → Pages → choose main branch).</li>
          <li>Open the published URL and allow camera access.</li>
        </ol>

        <h3>Notes & tips</h3>
        <ul class="small">
          <li>Calibration depends on your camera and lens — re-calibrate if changing devices.</li>
          <li>Distance estimate is approximate — good for relative distance / demo purposes.</li>
          <li>If the model fails to load, check network / CDN access (this demo uses public CDNs).</li>
        </ul>

        <footer>Built with ❤️ using TensorFlow.js • Ready to run on GitHub Pages</footer>
      </div>
    </div>
  </div>

  <!-- Scripts: TensorFlow and COCO-SSD from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

  <script>
    // Simple single-file detector + color + distance
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');

    const cameraList = document.getElementById('cameraList');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const modelStatus = document.getElementById('modelStatus');
    const fpsEl = document.getElementById('fps');
    const lastDetect = document.getElementById('lastDetect');
    const focalEl = document.getElementById('focal');
    const estDistEl = document.getElementById('estDist');

    const knownWidthInput = document.getElementById('knownWidth');
    const knownDistanceInput = document.getElementById('knownDistance');
    const classForCalibration = document.getElementById('classForCalibration');
    const calibrateBtn = document.getElementById('calibrateBtn');

    const skipFrames = document.getElementById('skipFrames');
    const showBoxes = document.getElementById('showBoxes');
    const showLabels = document.getElementById('showLabels');

    let model = null;
    let stream = null;
    let running = false;
    let rafId = null;
    let frameCount = 0;
    let lastTime = performance.now();
    let lastFpsTime = performance.now();
    let framesForFps = 0;

    // Calibration storage (per session)
    let calibration = { focalLength: null, realWidthCm: null, calibratedClass: null };

    async function listCameras(){
      const devices = await navigator.mediaDevices.enumerateDevices();
      cameraList.innerHTML = '';
      devices.filter(d => d.kind === 'videoinput').forEach(d => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${cameraList.length+1}`;
        cameraList.appendChild(opt);
      });
    }

    async function startCamera(){
      if(stream) stopCamera();
      const deviceId = cameraList.value || undefined;
      stream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: deviceId ? { exact: deviceId } : undefined, width: { ideal: 640 }, height: { ideal: 480 } }, audio: false });
      video.srcObject = stream;
      await video.play();
      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;
    }

    function stopCamera(){
      if(stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      if(rafId) cancelAnimationFrame(rafId);
      running = false;
    }

    async function loadModel(){
      modelStatus.textContent = 'loading...';
      model = await cocoSsd.load();
      modelStatus.textContent = 'ready';
    }

    function drawBox(box, label, score, color){
      const [x,y,w,h] = box;
      ctx.lineWidth = 2;
      ctx.strokeStyle = color || '#00ffff';
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      if(showBoxes.checked) ctx.strokeRect(x,y,w,h);
      if(showLabels.checked){
        const text = `${label} ${(score*100).toFixed(1)}%`;
        ctx.fillRect(x, y-22, ctx.measureText(text).width+10, 20);
        ctx.fillStyle = '#fff';
        ctx.fillText(text, x+6, y-8);
      }
    }

    function averageColorInBox(box){
      const [x,y,w,h] = box.map(v=>Math.max(0,Math.floor(v)));
      try{
        const img = ctx.getImageData(x,y,w,h);
        const d = img.data; let r=0,g=0,b=0,cnt=0;
        for(let i=0;i<d.length;i+=4){ r+=d[i]; g+=d[i+1]; b+=d[i+2]; cnt++; }
        r=Math.round(r/cnt); g=Math.round(g/cnt); b=Math.round(b/cnt);
        return {r,g,b};
      }catch(e){return null}
    }

    function rgbToHex(c){ return '#' + ((1<<24) + (c.r<<16) + (c.g<<8) + c.b).toString(16).slice(1); }

    function estimateDistance(realWidthCm, perceivedPx){
      if(!calibration.focalLength) return null;
      // distance (cm) = (realWidthCm * focal) / perceivedPx
      return (realWidthCm * calibration.focalLength) / perceivedPx;
    }

    // Calibrate focal length using known object
    async function calibrate(){
      const knownWidth = parseFloat(knownWidthInput.value);
      const knownDistance = parseFloat(knownDistanceInput.value);
      const cls = classForCalibration.value;
      if(!knownWidth || !knownDistance){ alert('Masukkan known width & distance (cm)'); return; }
      // run single detection and find first matching class
      const predictions = await model.detect(video);
      const found = predictions.find(p => p.class.toLowerCase()===cls.toLowerCase());
      if(!found){ alert('Object not found. Pastikan objek berada di frame dan terdeteksi.'); return; }
      const perceivedPx = found.bbox[2]; // bbox width
      calibration.focalLength = (perceivedPx * knownDistance) / knownWidth;
      calibration.realWidthCm = knownWidth;
      calibration.calibratedClass = cls;
      focalEl.textContent = calibration.focalLength.toFixed(2);
      alert('Kalibrasi selesai — focal length disimpan (session).');
    }

    async function runDetection(){
      if(!model) return;
      if(!running) return;
      rafId = requestAnimationFrame(runDetection);
      frameCount++;
      const skip = parseInt(skipFrames.value || '1',10);
      if(frameCount % skip !== 0) return;

      // draw current frame to overlay (for sampling)
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.drawImage(video,0,0,overlay.width,overlay.height);

      const t0 = performance.now();
      const predictions = await model.detect(video);
      const t1 = performance.now();

      lastDetect.textContent = `${predictions.length} objects`;
      framesForFps++; if(performance.now() - lastFpsTime > 1000){ fpsEl.textContent = framesForFps; framesForFps=0; lastFpsTime=performance.now(); }

      // draw boxes and compute color + distance
      for(const p of predictions){
        const box = p.bbox; // [x,y,w,h]
        // draw semi-transparent rect behind label
        ctx.font = '14px Inter, Arial';
        drawBox(box, p.class, p.score, '#06b6d4');
        // sample color inside box
        const color = averageColorInBox(box);
        if(color){
          const hex = rgbToHex(color);
          // display small swatch at box top-right
          ctx.fillStyle = hex;
          ctx.fillRect(box[0]+box[2]-34, box[1]+4, 28, 18);
          // annotate color
          ctx.fillStyle = '#fff';
          ctx.fillText(hex, box[0]+box[2]-34, box[1]+36);
        }
        // distance
        if(calibration.focalLength && calibration.realWidthCm){
          const est = estimateDistance(calibration.realWidthCm, box[2]);
          if(est){
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            const txt = `${est.toFixed(0)} cm`;
            ctx.fillRect(box[0], box[1]+box[3]+4, ctx.measureText(txt).width+8, 18);
            ctx.fillStyle = '#fff';
            ctx.fillText(txt, box[0]+4, box[1]+box[3]+18);
            estDistEl.textContent = `${est.toFixed(0)} cm`;
          }
        }
      }

    }

    // Events
    startBtn.addEventListener('click', async ()=>{
      await listCameras();
      await startCamera();
      running = true;
      if(!model) await loadModel();
      runDetection();
    });
    stopBtn.addEventListener('click', ()=>{ stopCamera(); modelStatus.textContent='stopped'; });
    calibrateBtn.addEventListener('click', calibrate);

    // init
    (async ()=>{
      await listCameras();
      modelStatus.textContent = 'idle';
      // quick attempt to autostart if permission previously granted
      try{ const p = await navigator.permissions.query({name:'camera'}); if(p.state==='granted') startBtn.click(); }catch(e){}
    })();

    // handle resize
    window.addEventListener('resize', ()=>{ if(video.videoWidth){ overlay.width = video.videoWidth; overlay.height = video.videoHeight; }});
  </script>
</body>
</html>
